# XSS跨站脚本攻击


## XSS的定义

跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意代码，当用户浏览该页之时，嵌入其中Web里面的代码会被执行，从而达到恶意攻击用户的目的。


## XSS的原理

- 攻击者对含有漏洞的服务器发起XSS攻击（注入代码）。
- 诱使受害者打开受到攻击的服务器URL。
- 受害者在Web浏览器中打开URL，恶意脚本执行。


## XSS的攻击方式

1、***反射型***：发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS随响应内容一起返回给浏览器，最后浏览器解析执行XSS代码，这个过程就像一次反射，所以叫反射型XSS。

2、***存储型***：存储型XSS和反射型的XSS差别就在于，存储型的XSS提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。


## 防御措施

>原则：坚决不让数据变成可执行的代码，不信任任何用户的数据，严格区分数据和代码。

1、***编码***：对用户输入的数据进行HTML Entity编码

2、***过滤***：移除用户上传的DOM属性，如onerror等，移除用户上传的style节点、script节点、iframe节点等。

3、***校正***：避免直接对HTML Entity编码，使用DOM Prase转换，校正不配对的DOM标签。


## X-XSS-Protection

从IE8开始，IE浏览器内置了一个针对XSS攻击的防护机制，这个浏览器内置的防护机制就是所谓的XSS filter，这个防护机制主要用于减轻反射型XSS攻击带来的危害。

基于Webkit内核的浏览器（比如Chrome）随后也增加一个名为XSS auditor的防护机制，作用和IE中的XSS filter类似。

这两种XSS防护机制的目的都很简单，如果浏览器检测到了含有恶意代码的输入被呈现在HTML文档中，那么这段呈现的恶意代码要么被删除，要么被转义，恶意代码不会被正常的渲染出来，当然了，浏览器是否要拦截这段恶意代码取决于浏览器的XSS防护设置。

至于怎么设置浏览器的XSS防护机制，其实很简单，只要在HTTP响应报文的头部增加一个`X-XSS-Protection`字段，明确地告诉浏览器XSS filter/auditor该如何工作。X-XSS-Protection的字段有三个可选配置值：

- `0`：表示关闭浏览器的XSS防护机制（所以本地演示XSS攻击时，记得要在响应头里添加这个值，否则演示不成功的，因为0不是默认值）
- `1; mode=block`：如果检测到恶意代码，则不渲染恶意代码（新版本的chrome默认采用这个设置）
- `1`：删除检测到的恶意代码，如果响应报文中没有看到X-XSS-Protection字段，那么浏览器就认为X-XSS-Protection配置为1，这是浏览器的默认设置（以前的默认设置）


### X-XSS-Protection值为`1`时可能存在的安全隐患问题：

***1、可被用来选择性地删除页面中的某些脚本。***

比如在url中添加script标签，然后src指向的地址与页面html本身自有script标签src指向了同一个js脚本地址——比如`jQuery`库，那么`jQuery`库竟然被意外的删除了。

之所以会出现这样的现象，是因为浏览器的`XSS auditor`分不清`jQuery`库是页面本身自带的还是攻击者注入的。

如果这次被意外删除的是一个和安全相关的js库，你可以想象，攻击者注入一个和含有js安全库名字的恶意代码，这样就可以把这个js安全库给删除了。


***2、会引入新的漏洞***

早在2009年，IE浏览器就因为`XSS filter`的缺陷被爆出一个`UXSS`漏洞。实际上，攻击者可以将无害的标签变成有害的标签，因为过滤器有时候很傻，会不正确地替换了关键位置的字符，从而损害了原始文档的结构。

通过精心制作的有效载荷，可以绕过属性下文的限制。 最近，很多类似`UXSS`的漏洞被发现，这些漏洞本质上的原因都是一样的。


***3、必然会有绕过`XSS filter/auditor`的方法出现***

不信你可以看看以前被绕过的例子。从这些被绕过的案例中，我们可以发现，不管`XSS filter/auditor`的过滤多么严格，它总存在被绕过的可能，此外，`XSS filter/auditor`在某些场景下是有短板的，`Chromium`小组曾经很明确的表明：`XSS auditor`只是众深防御的一环，完全靠它是无法防止所有XSS攻击的。


## XSS攻击常见场景

***术语（必读）：***

下文会用到`JavascriptEncode`、`CSSEncode`、`HTMLEncode`、`URLEncode`等术语，这不是一个某种语言里面的内置函数，而是一种函数的实现，可以将某些数据转义成特定语言的数据：

如`HTMLEncode`函数实现应该至少进行`&`、`<`、`>`、`"`、`'`、`/`等符号转义成`&amp;`、`&lt;`、`&gt;`、`&quot;`、`&#x27;`、`&#x2F;`。

如`JavascriptEncode`应将某些字符转义，如`"`变成`\"`、`'`变成`\'`等等


### A: 后端》》》》》》CSS
 
输出到CSS通常不会出现什么XSS，但是如果CSS里面有可能的用户完全可以控制的变量，如果我可以自定义style属性而且没过滤，或者可以直接控制某段CSS。其实我们通过http(s)协议直接引用第三方css文件时，第三方的代码内容是不受我们控制的，理论上里面也可以出现带有XSS攻击性质的代码，我们默认会信任一些比较流行的第三方地址，但这并不保证绝对安全。

```html
<p style="background-image: url(javascript:alert('xss'));">
```

//同理
```html
<style>
#id { background-image: url(javascript:alert('xss'));}
</style>
```

这样就可以利用伪协议来实现。

解决方案：

对`style`属性/标签里面的数据进行严格的检查，并且对于用户输出到`xss`里面的内容进行适当的`CSS`编码。


### B: 后端》》》》》》 Javascript

这种直接输出的`js`又不过滤简直就是老掉牙的`xss`漏洞。

```javascript
var x ="";
// 如果假设用户可以控制x变量，用户输入 ";alert(/xss/);//，那么这串代码会变成
var x ="";alert(/xss/);//"; // 最外侧双引号中间部分是用户输入的字符
// 执行了额外的代码，成功弹出提示框
```

当然还有一堆方法实现各种`xss`，各种姿势。所以这种是最最最简单的`xss`也是最容易被利用的。

解决方法：

对其进行严格的`JavascriptEncode`，将某些字符转义，如`"`变成`\"`、`'`变成`\'`等等（不止这些）防止用户逃脱你的双（单）引号，也可以防止其他姿势注入。


### C: Javascript》》》》》》生成HTML元素或添加html元素属性

如`js`给`<div>`添加`height`属性变成`<div height="200px">`

对于这个时候，从js输出数据到属性或`innerHTML`/`document.write`等函数生成任何元素，都要视为一次可能的XSS输出。因为上下文已经不一样了，这次`JavascriptEncode`是不对的。

否则你只能保证数据在js里面不会被注入，而在html的话，就不一定了。

解决方法：

应该使用`HTMLEncode`编码，保证你从`js`输出到`HTML`的元素和属性不会脱离你的控制。


### D: Javascript》》》》》》输出到HTML元素里面的事件，或其他任何动态执行js的地方

列如下列一段代码。

```html
<script>document.write("<img onload='" + var + "'>");</script>
<img onload='alert("var");'>
```

那么我完全可以跟上次一样，输入`";alert(/xss/);//`，***即使你第一次从后端到`js`使用了一次`jsEncode`，但是很遗憾，输出到html事件（write函数）后代码会转义回来***，所以我依然执行了。

则会变成: 

```html
<img onload='alert("";alert(/xss/);//");'>
```

可以看见，当你加载完毕之后，恭喜执行我的恶意代码。

解决方案：

使用`JavascriptEncode`，对事件里面的`js`代码进行编码。这里也必须视为一次可能的`XSS`输出。


## E:后端 》》》》》》输出到HTML元素里面的事件 或其他任何动态执行js的地方

这个情况简直可以视为跟`D`是一模一样的，所以你只需要理解`D`情况，那么这个也就自然可以理解了。

```html
<img onload='var'>
```

如果`var`是后端直接未经过处理输出，则输入`';alert(/xss/);//`则触发XSS。

解决方法：

也是对var进行`JavascriptEncode`。


### F:后端 》》》》》》生成HTML元素或添加html元素属性

与`C`情况也是一模一样。只是输出源不同了而已，原理模式都一样。

```php
<div>
$var
</div>
```

如果`$var`是后端输出的，那么我可以输入`<script>alert(/xss/)</script>`或`<img scr='' onerror='alert(/xss/)'>`

总之这样很容易注入`XSS`

解决方法：

对`var`变量进行`HtmlEncode`，那么我就无论如何也构建不了`<>`任何元素了。也就不可能有`<script>`或新建元素利用`onload`事件等。


### 上文总结：

仔细理解一下这些，你就会豁然开朗，总之，数据与代码要严格分离，然后要观察输出到哪，输出的上下文环境是什么。

切记：从一种代码到另外一种代码都要视为一次可能出现的`XSS`，因为原先转义的字符会在输出的时候转义回来.

比如`\"`会变回`"`，因为浏览器要确保用户看见的是`"`而不是`\"`，否则业务就错误了，你总不想你写个名字是`Suwings'blog`结果刷新之后变成`Suwings\'blog`吧。。。


## Reference

- [XSS 跨站脚本攻击 的防御解决方案](https://www.cnblogs.com/suwings/p/6285340.html)
- [安全隐患，你对X-XSS-Protection头部字段理解可能有误](http://www.freebuf.com/articles/web/138769.html)
- [Web安全之XSS攻防](https://blog.csdn.net/ganyingxie123456/article/details/70230486)
