# 事件捕获和冒泡

## 事件流

JavaScript与HTML之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器来预订事件，以便事件发生时执行相应的代码。

事件流的起源：就是在浏览器发展到第四代的时候，浏览器开发团队遇到一个问题：页面的哪一部分会拥有某个特定的事件？要明白这个问题问的是什么，可以想象画在一张纸上的一组同心圆。如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是纸上的所有圆。也就是说如果单击了页面的某个按钮，同时也单击了按钮的容器元素，甚至单击了整个页面。不过呢，IE提出的是冒泡流，而网景提出的是捕获流。

IE提出的是冒泡流，而网景提出的是捕获流，后来在W3C组织的统一之下，JS支持了冒泡流和捕获流，但是目前低版本的IE浏览器还是只能支持冒泡流(IE6,IE7,IE8均只支持冒泡流)，所以为了能够兼容更多的浏览器，建议大家使用冒泡流。

需要知道：

1、一个完整的JS事件流是从window开始，最后回到window的一个过程

2、事件流被分为三个阶段：捕获过程、目标过程、冒泡过程


## 三个阶段解释如下

- 捕获阶段：首先window会获捕获到事件，之后document、documentElement、body会捕获到，再之后就是在body中DOM元素一层一层的捕获到事件。

- 目标阶段：真正点击的元素的事件发生了两次，因为既在捕获阶段绑定了事件，又在冒泡阶段绑定了事件，所以发生了两次。***但是这里有一点是需要注意，在目标阶段并不一定先发生在捕获阶段所绑定的事件，而是先绑定的事件发生***。

- 冒泡阶段：会和捕获阶段相反的步骤将事件一步一步的冒泡到window。


## 两个属性：e.target和e.currentTarget

target和currentTarget都是event上面的属性，target是真正发生事件的DOM元素，而currentTarget是当前事件发生在哪个DOM元素上。

可以结合控制台打印出来的信息理解下，目标阶段也就是 target == currentTarget的时候。我没有打印它们两个因为太长了，所以打印了它们的nodeName，但是由于window没有nodeName这个属性，所以是undefined。


## 我们不用addEventListener绑定的事件会发生在哪个阶段呢

- 被点击的元素，也就是目标元素，***在目标元素上就不会遵守先发生捕获后发生冒泡这一规则，而是先绑定的事件先发生。***

- 非目标元素，其上绑定的事件会遵守先发生捕获后发生冒泡的规则。***所以很明显用onclick直接绑定的事件发生在了冒泡阶段。***


## Reference

- [事件冒泡、事件捕获和事件委托](https://www.cnblogs.com/Chen-XiaoJun/p/6210987.html)
